---
title: "Shape analysis for skin reflectance spectrum"
author: "Junhui He"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: yes
    number_sections: yes
editor_options:
  chunk_output_type: console
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# Load required libraries
library(knitr)
library(patchwork)
library(tidyverse)
library(scales)
library(dplyr)

library(openxlsx)

# Set global chunk options for the document
knitr::opts_chunk$set(
  echo = FALSE,        # Don't show code in output
  include = TRUE,      # Include output
  eval = TRUE,         # Evaluate code chunks
  warning = FALSE,     # Don't show warnings
  message = FALSE,     # Don't show messages
  fig.retina = 2,      # Higher resolution figures
  fig.width = 8,       # Default figure width
  fig.height = 6,      # Default figure height
  out.width = "100%"   # Full width in HTML output
)
```

# Introduction to the ISSA Dataset

The International Skin Spectra Archive (ISSA) offers a detailed collection of spectral and colorimetric data for human skin, encompassing 15,256 records from 2,113 subjects. This data spans from 2012 to 2024 and originates from eleven datasets curated by international laboratories across eight countries: the UK, Spain, China, Japan, Pakistan, Thailand, Iraq, and Saudi Arabia. Each dataset follows a standardised measurement protocol to maintain data consistency.

In the ISSA dataset, individual records provide extensive details including record number, data origin, subject identification, and skin type—categorised by ethnicity, gender, age, and body location. The dataset also includes detailed information on the measurement instruments used, such as type, specular component inclusion, wavelength range and interval.

Alongside spectral data, each sample also contains CIE colorimetric data, including tristimulus values, xy chromaticity coordinates, CIELAB parameters, etc., based on the CIE 1931 standard colorimetric observer and the CIE standard illuminant D65.

## Data Records

The datasheet arranges data across columns labelled A to BQ:

-   A: Unique record identifier
-   B: Data origin
-   C: Subject number
-   D to G: Ethnicity, gender, age group, and body location
-   H to L: Instrument details including type and spectral measurement specifics
-   N to BD: Spectral data from 360 nm to 780 nm
-   BF to BQ: CIE colorimetric data

## Skin Type

-   **Ethnicity**: CA (Caucasian), CN (Chinese), SA (South Asian), AF (African), IQ (Iraqi), TH (Thai), JP (Japanese), AB (Arabian)
-   **Gender**: F (Female), M (Male)
-   **Body Location**: 1 (Back of Hand), 2 (Cheek), 3 (Cheek bone), 4 (Chin), 5 (Ear Lobe), 6 (Forehead), 7 (Inner arm), 8 (Neck), 9 (Nose tip), 10 (Outer arm), 11 (Palm), 12 (Ring finger)

## Visualization

```{r load_issa}
# Load the ISSA skin spectrum reflectance data
issa_path <- "G:/Phd/Colloborator/Tina Lasisi/Meta/ISSA_17_Jan_2025_Yan_Lu.xlsx"
# issa_path <- "/Users/hjh/PhD/Meta/ISSA_17_Jan_2025_Yan_Lu.xlsx"
issa_code <- read.xlsx(issa_path, sheet = 1)
issa_data <- read.xlsx(issa_path, sheet = 2)

# Extract the skin spectrum data
issa <- issa_data[10:nrow(issa_data), ] # 360 nm: 13rd column, 780 nm: 55th column
colnames(issa) <- issa_data[9, ]

# Calculate melanin index using the formula from the literature
# This uses the red region of the spectrum (640-670nm)
issa = issa %>% 
    mutate(
      # Average reflectance in the red region
      eqn1 = ((`650` + `660` + (0.5 * `640`) + (0.5 * `660`)) / 3) / 100,
      # Convert to melanin index
      cmi = 100 * log10(1 / eqn1)
    )
```

```{r util_plot_functions}
# ==============================================================================
# DATA PROCESSING FUNCTIONS
# ==============================================================================

#' Calculate melanin index and prepare data for plotting
#' 
#' This function:
#' 1. Calculates the melanin index (CMI) using wavelengths 640-670nm
#' 2. Filters data to reasonable CMI range (20-130)
#' 3. Samples data to prevent plot overload
#' 4. Converts to long format for ggplot
#' 
#' @param data Processed spectral data frame
#' @param sample_size Number of spectra to sample (default 400)
#' @return Long-format data frame with id, wavelength, reflectance, and cmi
calculateMIndex <- function(data) {
  
  # Prepare data for plotting
  data_long <- data %>%
    #mutate(id = row_number()) %>%
    # Filter to reasonable melanin index range
    # filter(cmi >= 20 & cmi <= 130) %>% 
    # Sample to prevent plot overload
    # slice_sample(n = sample_size) %>% 
    # Convert to long format
    pivot_longer(cols = matches("^[0-9]+$"), 
                 names_to = "wavelength", 
                 values_to = "reflectance") %>% 
    # Extract numeric wavelength values
    mutate(wavelength = as.numeric(str_remove(wavelength, "\\D+"))) %>% 
    # Focus on visible spectrum
    filter(wavelength >= 400 & wavelength <= 700) # %>%
    # select(id, everything())
  
  return(data_long)
}

# ==============================================================================
# PLOTTING FUNCTIONS
# ==============================================================================

#' Generate skin spectra plot
#' 
#' Creates a plot showing reflectance spectra colored by melanin index
#' 
#' @param data Long-format data with wavelength, reflectance and cmi
#' @return A ggplot object
PlotSkinSpectra <- function(data) {
  plot <- ggplot(data, aes(x = wavelength, y = reflectance, group = A,
                          color = cmi)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
    expand_limits(y = 0) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Reflectance percentage of skin",
      color = "Melanin index"
    ) +
    guides(color = guide_colorbar(reverse = TRUE)) +
    # Highlight the region used for melanin index calculation
    annotate("rect", xmin = 640, xmax = 670, ymin = 0, ymax = 70,
             alpha = 0.3, fill = "#ff0000")
  
  return(plot)
}

#' Wrapper function to process file and generate plot
#' 
#' @param file_name Path to the CSV file
#' @return A ggplot object
PlotSkinSpectraWrapper <- function(data) {
  
  # Calculate melanin index
  data_with_mindex <- calculateMIndex(data)
  
  # Generate the plot
  plot <- PlotSkinSpectra(data_with_mindex)
  
  return(plot)
}
```

We visualize the skin reflectance curves across all ethnicity and body locations in the following figure:

```{r plot_reflectance}
plot_reflectance = PlotSkinSpectraWrapper(issa) + labs(title = "ISSA skin reflectance curves", subtitle = "including all ethnicity and body locations")
plot_reflectance
```

Furthermore, we visualize the skin reflectance curves per body location in the following figure:

```{r plot_body, fig.height=12}
bodys = as.character(1:12)
body_names = c("Back of Hand", "Cheek", "Cheek bone", "Chin", "Ear Lobe", "Forehead", "Inner arm", "Neck", "Nose tip", "Outer arm", "Palm", "Ring finger")

plots_body_list = list()
for (iloc in bodys) {
  issa_body = issa %>% filter(G == iloc)
  plot_body = PlotSkinSpectraWrapper(issa_body) + labs(title = body_names[as.numeric(iloc)])
  plots_body_list[[iloc]] = plot_body
}

wrap_plots(plots_body_list, ncol = 3, guides = "collect") + plot_annotation(title = "ISSA skin reflectance curves", subtitle = "vary among body locations") & theme(
    legend.position = "bottom")
```

# Derivative analysis

## First derivative calculation

We calculate the derivatives of the function to measure its growth rate. Especially, we estimate the first derivatives using local polynomial regression. The polynomial degree is 2, and the bandwidth is selected by direct plug-in methodology, which is about 13 nm.

```{r derivatives}
# plot the first derivatives
PlotDerivative <- function(data) {
  # Prepare data for plotting
  data_long <- data %>%
    # Convert to long format
    pivot_longer(cols = matches("^[0-9]+$"), 
                 names_to = "wavelength", 
                 values_to = "delta") %>% 
    # Extract numeric wavelength values
    mutate(wavelength = as.numeric(str_remove(wavelength, "\\D+"))) %>% 
    # Focus on visible spectrum
    filter(wavelength >= 400 & wavelength <= 700) # %>%
    
  plot <- ggplot(data_long, aes(x = wavelength, y = delta, group = A,
                          color = cmi)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    geom_hline(yintercept = 0, color = "red") +
    # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
    expand_limits(y = 0) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Derivatives of skin reflectance percentage",
      title = "First derivatives of skin reflectance percentage",
      color = "Melanin index"
    ) +
    guides(color = guide_colorbar(reverse = TRUE))
  
  return(plot)
}
```

```{r loc-poly}
# estimate the derivatives using local polynomials
library(KernSmooth)

issa_spec = as.matrix(issa %>% dplyr::select("400":"700")) # visible spectrum
wavelength = seq(400, 700, 10) # wavelength grid points

drv_est = t(apply(issa_spec, 1, function(spec) {
  drv_est = locpoly(x=wavelength, y=spec, drv=1, degree=2, bandwidth=11, gridsize=length(wavelength))
  drv_est$y
})) # estimate the first derivatives using local polynomials

colnames(drv_est) = wavelength
drv_est_df = as.data.frame(drv_est) %>% mutate(A = issa$A, cmi = issa$cmi)

plot_derivative = PlotDerivative(drv_est_df)
plot_derivative
```

There is one first-derivative curve that behaves noticeably differently, particularly around the 700 nm wavelength. To examine whether it is an outlier, we plot its reflectance values and derivatives side by side.

```{r outlier-der, fig.height=4.5}
# plot the outlier
out_idx = which(drv_est[,31] > 2)
plot_out_drv = PlotDerivative((drv_est_df[out_idx,])) + labs(title = "First derivatives")
plot_out_val = PlotSkinSpectraWrapper(issa[out_idx,]) + labs(title = "Function values")

wrap_plots(plot_out_val, plot_out_drv, ncol = 2, guides = "collect") + plot_annotation(title = "Outlier of ISSA skin reflectance spectrum") & theme(
    legend.position = "bottom")
```

Then we remove the outlier, and plot the first derivatives without outlier.

```{r remove-outlier}
drv_est = drv_est[-out_idx, ]
drv_est_df = drv_est_df[-out_idx, ]

PlotDerivative(drv_est_df)
```

```{r resample}
library(fda)

grid_size = 64 # the number of evaluated points
common_wave = seq(400, 700, length.out = grid_size)

# create basis representation
basis <- create.bspline.basis(rangeval = range(wavelength), nbasis = 25)

# resample skin reflectance
resample_skin_reflectance = sapply(c(1:nrow(issa_spec)), function(i) {
  y = issa_spec[i,]
  fd_obj = smooth.basis(wavelength, y, basis)$fd
  # evaluate function at common grid
  eval.fd(common_wave, fd_obj)
}) |> t()

colnames(resample_skin_reflectance) = common_wave

write.csv(resample_skin_reflectance[-out_idx,], file = "data/resample_skin_reflectance.csv", row.names = FALSE)

# resample derivatives
resample_drv = sapply(c(1:nrow(drv_est)), function(i) {
  y = drv_est[i,]
  fd_obj = smooth.basis(wavelength, y, basis)$fd
  # evaluate function at common grid
  eval.fd(common_wave, fd_obj)
}) |> t() # estimate the first derivatives using local polynomials

colnames(resample_drv) = common_wave

write.csv(resample_drv[-out_idx,], file = "data/resample_derivative.csv", row.names = FALSE)
```

## Variations in the first derivatives

We observe that higher curves tend to be more oscillatory, whereas lower curves appear flatter. To examine this pattern, we compute the standard deviation of the first derivatives as a measure of oscillation. The figures below show a clear negative relationship between the variation of the first derivatives and melanin index.

```{r var_in_derivatice}
sd_der = apply(drv_est, 1, sd) # standard deviation in first derivatives

ggplot() +
  geom_point(aes(x = issa$cmi[-out_idx], y = sd_der), size = 0.5) +
  theme_classic() +
  labs(
    x = "Melanin index",
    y = "Standard deviation in first derivatives",
    title = "Variations in first derivatives versus melanin index"
  )
```

## Peak and valley detection

From the derivative plot, we observe roughly three peaks or valleys within the ranges [410, 500], [500, 570], and [570, 700]. Our goal is to identify the locations of these peaks and valleys, as they provide biologically meaningful information. For each skin reflectance curve, we partition it into the three ranges and determine the corresponding peak or valley within each range. We then collect these peak/valley locations across all curves. The resulting peak/valley samples are displayed as the following boxplot.

```{r peak_drv}
peak_wrs = list(c(410, 500), c(570, 700)) # peak wavelength range
peaks = list()
for (i in c(1:2)) {
  wr = peak_wrs[[i]]
  col_start = which(wavelength == wr[1])
  col_end = which(wavelength == wr[2])
  peak = apply(drv_est, 1, function(drv) {
    peak_idx = which.max((drv[col_start:col_end]))
    wavelength[col_start:col_end][peak_idx]
  })
  peaks[[i]] = peak
}

valley_wr = c(500, 570)
wr = valley_wr
col_start = which(wavelength == wr[1])
col_end = which(wavelength == wr[2])
valley = apply(drv_est, 1, function(drv) {
  peak_idx = which.min((drv[col_start:col_end]))
  wavelength[col_start:col_end][peak_idx]
})

valley_idx = drv_est[cbind(c(1:nrow(drv_est)), (valley - 390)/10)]<0 # filter the negative derivatives
valley = valley[valley_idx]

# create a long data frame
pv_df = data.frame(wavelength = c(peaks[[1]], valley, peaks[[2]]),
                   group = c(rep("A", length(peaks[[1]])), rep("B", length(valley)), rep("C", length(peaks[[2]]))))
pv_df$group = factor(pv_df$group, levels = c("A", "B", "C"), labels = c("First peak", "Valley", "Second peak"))

ggplot(pv_df, aes(x = group, y = wavelength, fill = group)) +
  geom_boxplot() +
  labs(title = "Boxplots of peaks/valleys across all curves") +
  theme_classic()
```

```{r peak_drv_summary}
drv_summary = data.frame(group = c("First peak", "Valley", "Second peak"),
                         rbind(summary(peaks[[1]]), summary(valley), summary(peaks[[2]])))
kable(drv_summary, col.names = c("group", "min", "25% quantile", "median", "mean", "75% quantile", "max"), caption = "The summary of peak/valley estimation")
```

## Calculate melanin index at the peak wavelength

From the peak–valley analysis, the valley wavelength is 530 nm and the highest (second) peak occurs at 600 nm. Biologically, the valley wavelength is associated with the erythema index, while the peak wavelength is associated with the melanin index. Accordingly, we compute the erythema index at 530 nm and the melanin index at 600 nm. In subsequent visualizations, we color the skin reflectance curves by a modified melanin index evaluated at the peak wavelengths identified in our analysis.

```{r melanin-index}
#' Generate skin spectra plot
#' 
#' Creates a plot showing reflectance spectra colored by melanin index
#' 
#' @param data Long-format data with wavelength, reflectance and cmi
#' @return A ggplot object
PlotSkinSpectra <- function(data) {
  plot <- ggplot(data, aes(x = wavelength, y = reflectance, group = A,
                          color = cmi)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
    expand_limits(y = 0) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Reflectance percentage of skin",
      color = "Melanin index"
    ) +
    guides(color = guide_colorbar(reverse = TRUE)) +
    # Highlight the region used for melanin index calculation
    geom_vline(xintercept = 600, color = "#ff0000")
  
  return(plot)
}


issa = issa %>% 
  mutate(
    old_eqn1 = eqn1,
    old_cmi = cmi,
    # Average reflectance in the red region
    eqn1 = (`600`) / 100,
    # Convert to melanin index
    cmi = 100 * log10(1 / eqn1)
    )

PlotSkinSpectraWrapper(issa) + labs(title = "ISSA skin reflectance curves", subtitle = "melanin index calculated at 600 nm")
```

# Within-individual analysis

In this section, we explore the relationship between skin reflectance spectrum at different body locations within the same individual. We will visualize the skin reflectance curves colored by body location to examine the dependency across body parts. Furthermore, we will predict the skin reflectance spectrum at one body location conditioned on other body locations.

## Visualize within-individual skin reflectance curves at different body locations

The following figure shows the skin reflectance curves for nine randomly selected individuals.

```{r plot_within_individual, fig.height=10}
set.seed(1234)
sub_ids = unique(issa$C) # all subjects
sub_ids = sample(sub_ids, 9) # sample nine individuals

PlotWithinSkin <- function(data) {
  data = calculateMIndex(data)
  plot <- ggplot(data, aes(x = wavelength, y = reflectance, group = A,
                          color = G)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    ylim(0, 80) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Reflectance percentage of skin",
      color = "Body location"
    )
  
  return(plot)
}

plots_within_list = list()
my_colors = c("1" = "#e41a1c", "2" = "#377eb8", "3" = "#4daf4a", "4" = "#984ea3", "5" = "#ff7f00", "6" = "#ffff33", "7" = "#a65628", "8" = "#f781bf", "9" = "#999999", "10" = "#66c2a5", "11" = "#fc8d62", "12" = "#8da0cb")
for (isub in sub_ids) {
  issa_sub = issa %>% filter(C == isub)
  issa_sub$G = factor(issa_sub$G, levels = bodys)
  plot_within = PlotWithinSkin(issa_sub) + labs(title = paste("Subject", isub)) + 
    scale_color_manual(values = my_colors, 
                       limits = bodys,
                       labels = body_names)
  plots_within_list[[isub]] = plot_within
}


wrap_plots(plots_within_list, ncol = 3) + plot_annotation(title = "ISSA skin reflectance curves within the same individual") & theme(
    legend.position = "none")
```

## Predict skin reflectance spectrum at one body location conditioned on other body locations

We use separate linear regression models to predict the skin reflectance spectrum at a given body location using spectra from other locations, wavelength by wavelength. Specifically, at wavelength $t$, let the reflectance curve at the target body location be denoted by $Y_i(t)$, and the reflectance curves at the other locations by $X_{i1}(t),\ldots, X_{iJ}(t)$. We fit the model $$Y_i(t) = \sum_{j=1}^J X_{ij}(t)\beta_j(t) + \varepsilon_i(t),$$ where $t$ ranges from 400 nm to 700 nm, and $\beta_j(t)$ is the coefficient function for body location $j$, and $\varepsilon_i(t)$ is the residual error term.

Due to the limited number of individuals with measurements across all 12 body locations, we restrict attention to the 225 individuals with complete measurements at 8 body locations: Cheek, Forehead, Chin, Back of Hand, Inner arm, Outer arm, Neck and Palm. The following table shows the number of individuals with measurements available at each location.

```{r body_location_summary}
body_summary = issa %>% group_by(G) %>% summarise(n = n())
body_summary = body_summary[order(body_summary$n, decreasing = TRUE),]
body_summary = body_summary %>% mutate(body_location = body_names[as.numeric(G)])

kable(body_summary %>% dplyr::select(body_location, n), col.names = c("Body location", "Number of individuals"), caption = "The number of individuals with measurements at different body locations")
```

The skin reflectance curves for the 225 individuals at the 8 body locations are shown in the following figure.

```{r predict_within_individual, fig.height = 10}
# find individuals with measurements at least 8 body locations
sub_ids = unique(issa$C)
bodys_reg = body_summary$G[1:8]
body_names_reg = body_names[as.numeric(bodys_reg)]
for (iloc in bodys_reg) {
  issa_body = issa %>% filter(G == iloc)
  sub_ids = intersect(sub_ids, issa_body$C)
}

issa_reg = issa %>% filter(C %in% sub_ids, G %in% bodys_reg)

plots_body_list = list()
for (iloc in bodys_reg) {
  issa_body = issa_reg %>% filter(G == iloc)
  plot_body = PlotSkinSpectraWrapper(issa_body) + labs(title = body_names[as.numeric(iloc)])
  plots_body_list[[iloc]] = plot_body
}

wrap_plots(plots_body_list, ncol = 3, guides = "collect") + plot_annotation(title = "ISSA skin reflectance curves for regression", subtitle = "vary among body locations") & theme(
    legend.position = "bottom")

# construct the data matrix
issa_within = array(NA, dim = c(length(sub_ids), length(wavelength), length(bodys_reg)))
dimnames(issa_within) = list(sub_ids, wavelength, body_names_reg)
for (i in 1:length(bodys_reg)) {
  iloc = bodys_reg[i]
  issa_body = issa_reg %>% filter(G == iloc)
  issa_within[,,i] = as.matrix(issa_body %>% dplyr::select("400":"700"))
}
```

The skin reflectance curves at the Forehead, Inner arm, Outer arm and Palm within the same individual are shown in the following figure.

```{r plot_within_individual_v2, fig.height=10}
set.seed(1234)
cmi_forehead = (issa_reg %>% filter(G == "6"))$cmi
quantiles = quantile(cmi_forehead, probs = seq(0.1, 0.9, 0.1))
indices = sapply(quantiles, function(q) {
  which.min(abs(cmi_forehead - q))
})
sample_ids = sub_ids[indices] # sample nine individuals

PlotWithinSkin_v2 <- function(data) {
  data = calculateMIndex(data)
  plot <- ggplot(data, aes(x = wavelength, y = reflectance, group = A,
                          color = cmi, shape = G)) +
    geom_line() +  # Add transparency to handle overlapping lines
    geom_point() +
    # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
    ylim(0, 80) +
    expand_limits(y = 0) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Reflectance percentage of skin",
      color = "Melanin index",
      shape = "Body location"
    ) +
    guides(color = guide_colorbar(reverse = TRUE)) +
    # Highlight the region used for melanin index calculation
    geom_vline(xintercept = 600, color = "#ff0000")
  
  return(plot)
}

plots_within_list = list()
for (isub in sample_ids) {
  issa_sub = issa %>% filter(C == isub, G %in% c("6", "7", "10", "11"))
  issa_sub$G = body_names[as.numeric(issa_sub$G)]
  plot_within = PlotWithinSkin_v2(issa_sub) + labs(title = paste("Subject", isub))
  plots_within_list[[isub]] = plot_within
}


wrap_plots(plots_within_list, ncol = 3, guides = "collect") + plot_annotation(title = "ISSA skin reflectance curves within the same individual", subtitle = "sorted by the melanin index at forehead from high to low") & theme(
    legend.position = "bottom")
```

Without loss of generality, we focus on predicting the skin reflectance spectrum at the **Palm** location using measurements from the other seven body locations. The 225 individuals are randomly divided into a training set of 180 and a test set of 45. At each wavelength, we fit the linear regression model using the training set and then predict the Palm reflectance spectrum for individuals in the test set.

```{r predict_palm}
set.seed(1234)
train_idx = sample(1:225, 180) # randomly select 180 individuals for training
test_idx = setdiff(1:225, train_idx) # the remaining 45 individuals for testing

train_data = issa_within[train_idx,,] # training data
test_data = issa_within[test_idx,,] # test data

palm_models = list()
pred_palm = array(NA, dim = c(length(test_idx), length(wavelength)))
colnames(pred_palm) = wavelength
for (iw in 1:length(wavelength)) {
  train_df = data.frame(train_data[,iw,])
  palm_model = lm(Palm ~ . , data = train_df)
  palm_models[[iw]] = palm_model
  
  test_df = data.frame(test_data[,iw,])
  pred_palm[,iw] = predict(palm_model, newdata = test_df)
}
```

The following figure shows the prediction versus ground truth results for 9 randomly selected individuals in the test set.

```{r predict_palm_plot, fig.height=10}
set.seed(1234)
test_sub_ids = sub_ids[test_idx]
test_sub_ids = sample(test_sub_ids, 9) # sample nine individuals

PlotPrediction <- function(data) {
  data = calculateMIndex(data)
  plot <- ggplot(data, aes(x = wavelength, y = reflectance, group = group,
                          color = group)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    ylim(0, 80) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Reflectance percentage of skin",
      color = "Type"
    )
  
  return(plot)
}

plots_pred_list = list()
for (isub in test_sub_ids) {
  isub_idx = which(test_sub_ids == isub)
  pred_sub = data.frame(rbind(test_data[isub_idx,,which(body_names_reg == "Palm")], pred_palm[isub_idx,]))
  colnames(pred_sub) = wavelength
  pred_sub$group = c("Ground truth", "Prediction")
  plot_pred = PlotPrediction(pred_sub) + labs(title = paste("Subject", isub))
  plots_pred_list[[isub]] = plot_pred
}


wrap_plots(plots_pred_list, ncol = 3, guides = "collect") + plot_annotation(title = "ISSA skin reflectance prediction versus ground truth", subtitle = "target body location: Palm") & theme(
    legend.position = "bottom")
```

The following figure shows the prediction results for all 45 individuals in the test set.

```{r predict_palm_all, fig.height=5}
true_palm_df = as.data.frame(test_data[,,which(body_names_reg == "Palm")]) %>% mutate(A = row_number(), eqn1 = (`600`) / 100, cmi = 100 * log10(1 / eqn1))

plot_true = PlotSkinSpectraWrapper(true_palm_df) + labs(title = "Ground truth") + ylim(0, 80)

pred_palm_df = as.data.frame(pred_palm) %>% mutate(A = row_number(), eqn1 = (`600`) / 100, cmi = 100 * log10(1 / eqn1))

plot_pred = PlotSkinSpectraWrapper(pred_palm_df) + labs(title = "Prediction") + ylim(0, 80)

wrap_plots(plot_true, plot_pred, ncol = 2, guides = "collect") + plot_annotation(title = "ISSA skin reflectance prediction results", subtitle = "target body location: Palm") & theme(
    legend.position = "bottom")
```

# Classify whether skin reflectance curves are realistic or not

In this section, we use the GAN discriminator embedding + Mahalanobis distance as a "realism score" model for skin reflectance curves. The input to the model is a skin reflectance curve with its first derivative $(x,x')\in \mathbb{R}^{2T}$ (fixed length after resampling). The output is a score indicating how realistic the input curve is. A higher score indicates a more realistic curve.

## Pipeline

1.  Prepare data.

  -   Gather real curves and calculate the derivatives. Resample to a common grid of length $T=64$. Concatenate the resampled curves and derivatives to form a $2T$-dimensional vector.

  -   Standardize per wavelength or per curve (z-score); keep stats from training only.

  -   Split: train (for GAN), val-ID (for threshold tuning).

2.  Model Choice.

  -   Use a WGAN-GP (more stable than vanilla GAN for 1-D signals).

  -   Generator $G(z)$: maps Gaussian noise to a curve.

  -   Discriminator/Critic $D(x)$: 1-D CNN that outputs a real number (the Wasserstein “realness” score).

3.  Train the GAN.

  -   Loss: WGAN with gradient penalty.

  -   Optimize $D$ several steps per $G$ step (e.g., 5:1).

4.  Fit a Gaussian to the discriminator features.

  -   Freeze $D$. Take the second-to-last layer of $D$ as an embedding.

  -   Pass all training data through $D$ to get training embeddings.

  -   Fit a Gaussian (mean $\mu$, covariance $\Sigma$) to the training embeddings.

5.  Calibrate the realism threshold.

  -   Pass val-ID data through $D$ to get val embeddings $e$. Compute Mahalanobis distances to $(\mu, \Sigma)$ by $(e-\mu)^\top \Sigma^{-1} (e-\mu)$ as an out-of-distribution (OOD) score.

  -   Choose a threshold $\tau$ on the OOD score to achieve a desired true positive rate (TPR) on val-ID.

6.  Inference.

  -   For a new curve, compute its derivative, resample, standardize, and concatenate to form $(x,x')$.

  -   Pass $(x,x')$ through $D$ to get embedding $e$. Score $s$ by Mahalanobis distance to $(\mu, \Sigma)$.

  -   If $s < \tau$, classify as realistic; else, non-realistic.

## Test evaluation

### Generate test set

We generate a test set of 600 curves, including 300 real curves from ISSA and 300 fake curves. The fake curves are generated from two categories: (1) sine wave with negative amplitude + noise; (2) sine wave with positive amplitude + noise. The following figure shows the real and fake skin reflectance curves in the test set.

```{r generate_test_set, fig.height=8}
set.seed(1234)
# real curves
real_indices = sample.int(nrow(issa), 300)
real_curves = issa[real_indices, ]

plot_real = PlotSkinSpectraWrapper(real_curves) + labs(title = "Real curves", subtitle = "from ISSA dataset")
# fake curves
# category 1
generate_fake_1 <- function(n = 100) {
  y = matrix(NA, nrow = n, ncol = length(wavelength))
  for (i in 1:n) {
    y[i, ] = 30 - 20 * sin(2*pi/450 * (wavelength - 400) + pi/3 + runif(1, -pi/12, pi/12)) + rnorm(length(wavelength), mean = 0, sd = 0.5)
  }
  return(y)
}
fake_1 = generate_fake_1(150)
colnames(fake_1) = wavelength
fake_df_1 = as.data.frame(fake_1) %>% mutate(A = row_number(), eqn1 = (`600`) / 100, cmi = 100 * log10(1 / eqn1))
plot_fake_1 = PlotSkinSpectraWrapper(fake_df_1) + labs(title = "Fake curves", subtitle = "category 1")
# category 2
generate_fake_2 <- function(n = 100) {
  y = matrix(NA, nrow = n, ncol = length(wavelength))
  for (i in 1:n) {
    y[i, ] = 30 + 20 * sin(2*pi/450 * (wavelength - 400) + pi/3 + runif(1, -pi/12, pi/12)) + rnorm(length(wavelength), mean = 0, sd = 0.5)
  }
  return(y)
}
fake_2 = generate_fake_2(150)
colnames(fake_2) = wavelength
fake_df_2 = as.data.frame(fake_2) %>% mutate(A = row_number(), eqn1 = (`600`) / 100, cmi = 100 * log10(1 / eqn1))
plot_fake_2 = PlotSkinSpectraWrapper(fake_df_2) + labs(title = "Fake curves", subtitle = "category 2")

# combine real and fake curves
fake_curves = rbind(fake_1, fake_2)
test_curves = rbind(as.matrix(real_curves %>% dplyr::select("400":"700")), fake_curves)
colnames(test_curves) = wavelength
resample_test_curves = sapply(c(1:nrow(test_curves)), function(i) {
  y = test_curves[i,]
  fd_obj = smooth.basis(wavelength, y, basis)$fd
  # evaluate function at common grid
  eval.fd(common_wave, fd_obj)
}) |> t()
colnames(resample_test_curves) = common_wave

write.csv(resample_test_curves, file = "data/test_skin_reflectance.csv", row.names = FALSE)

test_drv_est = t(apply(test_curves, 1, function(spec) {
  drv_est = locpoly(x=wavelength, y=spec, drv=1, degree=2, bandwidth=11, gridsize=length(wavelength))
  drv_est$y
})) # estimate the first derivatives using local polynomials

colnames(test_drv_est) = wavelength
test_curves_df = as.data.frame(test_curves) %>% mutate(A = row_number(), eqn1 = `600` / 100, cmi = 100 * log10(1 / eqn1))
test_drv_est_df = as.data.frame(test_drv_est) %>% mutate(A = row_number(), cmi = test_curves_df$cmi)

plot_real_drv = PlotDerivative(test_drv_est_df[1:300,]) + labs(title = "First derivatives", subtitle = "from ISSA dataset")
plot_fate_drv_1 = PlotDerivative(test_drv_est_df[301:450,]) + labs(title = "First derivatives", subtitle = "category 1")
plot_fate_drv_2 = PlotDerivative(test_drv_est_df[451:600,]) + labs(title = "First derivatives", subtitle = "category 2")
wrap_plots(plot_real, plot_fake_1, plot_fake_2, plot_real_drv, plot_fate_drv_1, plot_fate_drv_2, ncol = 3, guides = "collect") + plot_annotation(title = "Test skin reflectance curves") & theme(
    legend.position = "bottom")

resample_test_drv = sapply(c(1:nrow(test_drv_est)), function(i) {
  y = test_drv_est[i,]
  fd_obj = smooth.basis(wavelength, y, basis)$fd
  # evaluate function at common grid
  eval.fd(common_wave, fd_obj)
}) |> t() # estimate the first derivatives using local polynomials

colnames(resample_test_drv) = common_wave
write.csv(resample_test_drv, file = "data/test_derivative.csv", row.names = FALSE)
```

### Evaluate test set

We load the pre-trained GAN discriminator and Gaussian parameters to evaluate the test set. The following table shows the evaluation performance in the test set.

```{r evaluate_test_set}
test_evaluation_df = data.frame(Method = "GAN embedding + M-distance", Threshold = "5th quantile", ACC = 0.980, TPR = 0.960, FPR = 0.000, AUC = "> 0.99")
kable(test_evaluation_df, col.names = c("Method", "Threshold", "Accuracy", "True positive rate", "False positive rate", "AUROC"), caption = "The evaluation performance in the test set")
```

We also visualize the classification results in the test set. The following figure shows the skin reflectance curves classified as realistic and non-realistic, respectively.

```{r plot_test_set, fig.height=6}
s_pred = read.csv("data/s_pred.csv")$X0
y_pred = read.csv("data/y_pred.csv")$X0

plot_pred_real = PlotSkinSpectraWrapper(test_curves_df[y_pred == 1,]) + labs(title = "Predicted realistic skin reflectance curves", subtitle = paste("n =", sum(y_pred == 1)))
plot_pred_fake = PlotSkinSpectraWrapper(test_curves_df[y_pred == 0,]) + labs(title = "Predicted non-realistic skin reflectance curves", subtitle = paste("n =", sum(y_pred == 0)))

wrap_plots(plot_pred_real, plot_pred_fake, ncol = 2, guides = "collect") + plot_annotation(title = "Test skin reflectance curves classified by realism score") & theme(
    legend.position = "bottom")
```

The false negative cases are shown in the following figure.

```{r plot_false_negative, fig.height=4}
y_test = c(rep(1, 300), rep(0, 300))
false_negative_idx = which(y_test == 1 & y_pred == 0)
PlotSkinSpectraWrapper(test_curves_df[false_negative_idx,]) + labs(title = "False negative skin reflectance curves", subtitle = paste("n =", length(false_negative_idx)))
```

### Evaluate Generator

```{r evaluate_generator}
gen_curves = read.csv("data/fake_skin_reflectance.csv")
gen_derivatives = read.csv("data/fake_derivative.csv")
colnames(gen_curves) = common_wave
colnames(gen_derivatives) = common_wave
gen_curves_df = as.data.frame(gen_curves) %>% mutate(A = row_number(), eqn1 = (`600`) / 100, cmi = 100 * log10(1 / eqn1))
PlotSkinSpectraWrapper(gen_curves_df) + labs(title = "Generated skin reflectance curves", subtitle = "from GAN generator")
```

